use anyhow::{anyhow, bail, Context};
use core::fmt;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::str::FromStr;
use thiserror::Error;

use crate::lex::Token;
use crate::lex::{Lexer, Span, TokenInner};

#[allow(non_camel_case_types)]
#[rustfmt::skip]
#[derive(Serialize, Deserialize, PartialEq, Eq, Debug, Clone, Copy)]
pub enum Register {
    x0, ra, sp, gp, tp,
    t0, t1, t2, t3, t4, t5, t6,
    a0, a1, a2, a3, a4, a5, a6, a7,
    s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11,
}

#[derive(Error, Debug)]
pub enum RegisterParseError {
    // Note: we can't include the actual offending token here because anyhow
    // requires it's error's be 'static but the token would only live for 'a
    #[error("can only parse register out of ident, but got '{0}'")]
    InvalidToken(String),
    #[error("failed to parse register: {0}")]
    ParseError(String),
}

impl TryFrom<Token> for Register {
    type Error = RegisterParseError;

    fn try_from(token: Token) -> Result<Self, Self::Error> {
        match token.inner() {
            TokenInner::Ident(ident) => ident.parse().map_err(RegisterParseError::ParseError),
            other => Err(RegisterParseError::InvalidToken(other.to_string())),
        }
    }
}

/// Implement parse, display for Register
macro_rules! register_impls {
    ($( ($reg:ident = $xreg:ident) )*) => {
        impl std::str::FromStr for $crate::parse::Register {
            type Err = String;
            fn from_str(s: &str) -> Result<Register, Self::Err> {
                match s.trim() {
                    $(
                        stringify!($reg) | stringify!($xreg)
                            => Ok(Register::$reg),
                    )*
                    "zero" => Ok(Register::x0),
                    unknown => Err(format!("unrecognized register {unknown}"))
                }
            }
        }
        impl std::fmt::Display for $crate::parse::Register {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    $(
                        Register::$reg => write!(f, "{}", stringify!($reg)),
                    )*
                }
            }
        }
    }
}

register_impls! {
   (x0 = x0) (ra = x1) (sp = x2) (gp = x3) (tp = x4)

   (t0 = x5) (t1 = x6) (t2 = x7) (t3 = x28) (t4 = x29) (t5 = x30) (t6 = x31)

   (a0 = x10) (a1 = x11) (a2 = x12) (a3 = x13)
   (a4 = x14) (a5 = x15) (a6 = x16) (a7 = x17)

   (s0 = x8) (s1 = x9) (s2 = x18) (s3 = x19) (s4 = x20) (s5 = x21) (s6 = x22)
   (s7 = x23) (s8 = x24) (s9 = x25) (s10 = x26) (s11 = x27)
}

/// Declares an instruction type, as in `RegImm` or `Branch`.
///
/// Implements `FromStr` and `Display` for the new instruction type as well.
///
/// ```rust
/// # use crate::riscv::declare_instruction_set;
/// declare_instruction_set!(Vector, "simd", Broadcast => "broadcast", Fma => "fma");
/// ```
/// expands to something looking like
/// ```rust
/// # use serde::{Serialize, Deserialize};
/// # use std::str::FromStr;
/// # use std::fmt::Display;
/// # use anyhow::bail;
/// #[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
/// pub enum Vector {
///     Broadcast,
///     Fma
/// }
///
/// impl FromStr for Vector {
///     type Err = anyhow::Error;
///     fn from_str(s: &str) -> anyhow::Result<Self> {
///          match s {
///               "broadcast" => Ok(Self::Broadcast),
///               "fma" => Ok(Self::Fma),
///               other => bail!("unknown simd instruction: {other}")
///               //                      ^^^^ we control this
///          }
///     }
/// }
///
/// impl Display for Vector {
///     fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
///         write!(f, "{}", match self {
///             Self::Broadcast => "broadcast",
///             Self::Fma => "fma",
///         })
///     }
/// }
/// ```
#[macro_export]
macro_rules! declare_instruction_set {
    ($setname:ident, $displayname:literal, $($opname:ident => $opstr:literal),+ $(,)?) => {
        #[derive(Debug, Clone, Copy, ::serde::Serialize, ::serde::Deserialize, PartialEq, Eq)]
        #[doc = "this enum was generated by declare_instruction_set; see its docs"]
        pub enum $setname {
            $($opname),+
        }

        impl ::std::str::FromStr for $setname {
            type Err = ::anyhow::Error;

            fn from_str(s: &str) -> ::anyhow::Result<Self> {
                match s {
                    $($opstr => Ok(Self::$opname),)+
                    other => ::anyhow::bail!(concat!("unknown ", $displayname, " instruction: {}"), other)
                }
            }
        }

        impl ::std::fmt::Display for $setname {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "{}", match self {
                    $(Self::$opname => $opstr,)+
                })
            }
        }
    };
}

declare_instruction_set!(
    RegRegOp,
    "register-register",
    Add => "add",
    Sub => "sub",
    Sll => "sll",
    Slt => "slt",
    Sltu => "sltu",
    Xor => "xor",
    Srl => "srl",
    Sra => "sra",
    Or => "or",
    And => "and",
);

declare_instruction_set!(
    RegImmOp,
    "register-immediate",
    Addi => "addi",
    Slti => "slti",
    Sltiu => "sltiu",
    Xori => "xori",
    Ori => "ori",
    Andi => "andi",
    Slli => "slli",
    Srli => "srli",
    Srai => "srai",
);

declare_instruction_set!(
    StoreOp,
    "store",
    Sw => "sw",
    Sh => "sh",
    Sb => "sb",
);

declare_instruction_set!(
    LoadOp,
    "load",
    Lw => "lw",
    Lh => "lh",
    Lhu => "lhu",
    Lb => "lb",
    Lbu => "lbu",
);

declare_instruction_set!(
    BranchOp,
    "branch",
    Beq => "beq",
    Bne => "bne",
    Blt => "blt",
    Bge => "bge",
    Bltu => "bltu",
    Bgeu => "bgeu",
    Bgt => "bgt",
    Ble => "ble",
    Bgtu => "bgtu",
    Bleu => "bleu",
);

declare_instruction_set!(
    BranchZeroOp,
    "zero-branch",
    Beqz => "beqz",
    Bnez => "bnez",
    Bltz => "bltz",
    Bgez => "bgez",
    Bgtz => "bgtz",
    Blez => "blez",
);

declare_instruction_set!(
    LoadImmOp,
    "load-immediate",
    Lui => "lui",
    Li => "li",
);

declare_instruction_set!(
    UnaryOp,
    "unary",
    Mv => "mv",
    Not => "not",
    Neg => "neg",
);

#[rustfmt::skip]
#[allow(non_camel_case_types)]
#[derive(Serialize, Deserialize, Eq, PartialEq, Debug, Clone)]
pub enum Instruction {
    RegImm { rd: Register, r1: Register, imm: i32, op: RegImmOp },
    RegReg { rd: Register, r1: Register, r2: Register, op: RegRegOp },
    Load {rd: Register, offset: i32, r1: Register, op: LoadOp },
    Store {r2: Register, offset: i32, r1: Register, op: StoreOp },
    Branch  { r1: Register, r2: Register, label: String, op: BranchOp },
    LoadImm { rd: Register, imm: i32, op: LoadImmOp },
    BranchZero { r1: Register, label: String, op: BranchZeroOp },
    Unary { rd: Register, r1: Register, op: UnaryOp },

    // Calling and jumping
    call        { label: String },
    // Note: if a register is not provided, assume rd
    jal         { rd: Register, label: String },
    // Note: if a register is not provided, assume 0(rd)
    jalr        { rd: Register, offset: i32, r1: Register },
    j           { label: String },
    jr          { rs: Register },
    ret         {},
}

impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Instruction::RegImm { rd, r1, imm, op } => write!(f, "{op} {rd}, {r1}, {imm}"),
            Instruction::RegReg { rd, r1, r2, op } => write!(f, "{op} {rd}, {r1}, {r2}"),
            Instruction::Load { rd, offset, r1, op } => write!(f, "{op} {rd}, {offset}({r1})"),
            Instruction::Store { r2, offset, r1, op } => write!(f, "{op} {r2}, {offset}({r1})"),
            Instruction::Branch { r1, r2, label, op } => write!(f, "{op} {r1}, {r2}, {label}"),
            Instruction::LoadImm { rd, imm, op } => write!(f, "{op} {rd} {imm}"),
            Instruction::BranchZero { r1, label, op } => write!(f, "{op} {r1}, {label}"),
            Instruction::Unary { rd, r1, op } => write!(f, "{op} {rd}, {r1}"),
            Instruction::call { label } => write!(f, "call {label}"),
            Instruction::jal { rd, label } => write!(f, "jal {rd}, {label}"),
            Instruction::jalr { rd, offset, r1 } => write!(f, "jalr {rd}, {offset}({r1})"),
            Instruction::j { label } => write!(f, "j {label}"),
            Instruction::jr { rs } => write!(f, "jr {rs}"),
            Instruction::ret {} => write!(f, "ret"),
        }
    }
}

/// An item of RISC-V assembly, either an instruction or label (for now)
#[derive(Serialize, Deserialize, Eq, PartialEq, Debug, Clone)]
pub enum Item {
    Instruction(Instruction),

    // Include span info so that we can emit better error messages during the
    // post-processing stage of parsing, where we check that all labels accessed
    // actually exist and that no labels are defined more than once.
    Label { name: String, span: Span },
}

impl Item {
    /// Access the inner instruction. Panic if not called on an instruction.
    pub fn get_instruction(&self) -> &Instruction {
        match self {
            Item::Instruction(i) => i,
            Item::Label { .. } => unreachable!("unwrap_instruction called on label"),
        }
    }

    /// Access the inner label. Panic if not called on an label.
    pub fn get_label(self) -> String {
        match self {
            Item::Instruction(_) => unreachable!("unwrap_label called on instruction"),
            Item::Label { name, .. } => name,
        }
    }
}

type ParseResult = anyhow::Result<Item>;

impl<'a> Lexer<'a> {
    pub fn parse_item(&mut self) -> Option<ParseResult> {
        // Skip comments
        while matches!(
            self.peek(),
            Some(Ok(Token {
                inner: TokenInner::HashComment(_) | TokenInner::SlashComment(_),
                ..
            }))
        ) {
            self.next();
        }

        // Check if stream is empty
        self.peek()?;

        Some(self._parse_item())
    }

    // Assumes that there are tokens left in the stream and that the first comment
    // is not a token. The reason this method exists is so that we can use the
    // question mark with results, instead of options.
    fn _parse_item(&mut self) -> ParseResult {
        // Parsing a label
        let ident = self.ident()?;
        let (ident, span) = ident.unwrap_ident();
        if let Ok(TokenInner::Colon) = self.colon().map(|token| token.inner()) {
            return Ok(Item::Label { name: ident, span });
        }

        // We technically don't even need type hints here! I think it improves
        // readability though
        let instruction = if let Ok(op) = ident.parse::<RegImmOp>() {
            let rd = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let r1 = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let neg = self.minus().is_ok();
            let mut imm: i32 = self.constant()?.unwrap_constant().0;
            if neg {
                imm = -imm
            }
            Instruction::RegImm { rd, r1, imm, op }
        } else if let Ok(op) = ident.parse::<RegRegOp>() {
            let rd = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let r1 = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let r2 = self.ident()?.try_into()?;
            Instruction::RegReg { rd, r1, r2, op }
        } else if let Ok(op) = ident.parse::<BranchOp>() {
            let r1 = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let r2 = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let label = self.ident()?.unwrap_ident().0;
            Instruction::Branch { r1, r2, label, op }
        } else if let Ok(op) = ident.parse::<BranchZeroOp>() {
            let r1 = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let label = self.ident()?.unwrap_ident().0;
            Instruction::BranchZero { r1, label, op }
        } else if let Ok(op) = ident.parse::<UnaryOp>() {
            let rd = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let r1 = self.ident()?.try_into()?;
            Instruction::Unary { rd, r1, op }
        } else if let Ok(op) = ident.parse::<StoreOp>() {
            let r2 = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let neg = self.minus().is_ok();
            let mut offset = self.constant()?.unwrap_constant().0;
            if neg {
                offset = -offset
            }
            let _ = self.left_paren()?;
            let r1 = self.ident()?.try_into()?;
            let _ = self.right_paren()?;
            Instruction::Store { r2, offset, r1, op }
        } else if let Ok(op) = ident.parse::<LoadOp>() {
            let rd = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let neg = self.minus().is_ok();
            let mut offset = self.constant()?.unwrap_constant().0;
            if neg {
                offset = -offset
            }
            let _ = self.left_paren()?;
            let r1 = self.ident()?.try_into()?;
            let _ = self.right_paren()?;
            Instruction::Load { rd, offset, r1, op }
        } else if let Ok(op) = ident.parse::<LoadImmOp>() {
            let rd = self.ident()?.try_into()?;
            let _ = self.comma()?;
            let neg = self.minus().is_ok();
            let mut imm = self.constant()?.unwrap_constant().0;
            if neg {
                imm = -imm
            }
            Instruction::LoadImm { rd, imm, op }
        } else {
            // call        { label: &'a str },
            // jal         { rd: Register, label: &'a str },
            // jalr        { rd: Register, offset: i32, r1: Register },
            // j           { label: &'a str },
            // jr          { rs: Register },
            // ret         {},
            match ident.as_str() {
                "call" => {
                    let label = self.ident()?.unwrap_ident().0;
                    Instruction::call { label }
                }
                // Note: if a register is not provided, assume rd
                "jal" => {
                    let ident = self.ident()?;
                    if let Ok(rd) = ident.clone().try_into() {
                        // Register was provided, continue
                        let _ = self.comma()?;
                        let label = self.ident()?.unwrap_ident().0;
                        Instruction::jal { rd, label }
                    } else {
                        // Assume register is ra
                        Instruction::jal {
                            rd: "ra".parse().expect(""),
                            label: ident.unwrap_ident().0,
                        }
                    }
                }
                // Note: if a register is not provided, assume 0(rd)
                "jalr" => {
                    let reg = self.ident()?.try_into()?;
                    if let Ok(TokenInner::Comma) = self.comma().map(|token| token.inner()) {
                        let neg = self.minus().is_ok();
                        let mut offset = self.constant()?.unwrap_constant().0;
                        if neg {
                            offset = -offset
                        }
                        let _ = self.left_paren()?;
                        let r1 = self.ident()?.try_into()?;
                        let _ = self.right_paren()?;
                        Instruction::jalr {
                            rd: reg,
                            offset,
                            r1,
                        }
                    } else {
                        Instruction::jalr {
                            rd: "ra".parse().expect(""),
                            offset: 0,
                            r1: reg,
                        }
                    }
                }
                "j" => {
                    let label = self.ident()?.unwrap_ident().0;
                    Instruction::j { label }
                }
                "jr" => {
                    let rs = self.ident()?.try_into()?;
                    Instruction::jr { rs }
                }
                "ret" => Instruction::ret {},
                other => bail!("unknown instruction: {other}"),
            }
        };
        Ok(Item::Instruction(instruction))
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Program {
    // The values of this map are program counters the labels point to. The value
    // of a label divided by 4 points to the instruction in `asm` corresponding
    // to the label with the keyed name.
    labels: HashMap<String, usize>,
    pub asm: Vec<Instruction>,
}

impl FromStr for Program {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> anyhow::Result<Program> {
        let mut lexer = Lexer::new(s);
        Program::parse(&mut lexer)
    }
}

impl Program {
    // Get the raw items out of the lexer
    fn parse_items(lexer: &mut Lexer) -> anyhow::Result<Vec<Item>> {
        let mut items = vec![];
        while let Some(item) = lexer.parse_item() {
            // Context should be handled by caller
            items.push(item?);
        }
        Ok(items)
    }

    pub fn parse(source: &mut Lexer) -> anyhow::Result<Program> {
        // We use this to check if any labels are defined multiple times
        let mut labels2pcs: HashMap<String, usize> = HashMap::new();
        let mut labels2spans: HashMap<String, Vec<Span>> = HashMap::new();
        let items = Program::parse_items(source).context("failed to parse item")?;

        // Extract all label information
        let mut pc = 0;
        for item in items.iter() {
            let Item::Label { name, span } = &item else {
                pc += 4;
                continue;
            };

            labels2pcs.insert(name.clone(), pc);

            // Record the spans where each label is defined; there should only be one
            // for each label
            labels2spans
                .entry(name.clone())
                .and_modify(|spans| spans.push(span.clone()))
                .or_insert(vec![span.clone()]);
        }

        // We'll aggregate all errors onto this bad boy
        let mut errors: Vec<String> = vec![];

        // Make sure each label is defined at most once
        for (name, spans) in labels2spans.iter() {
            if spans.len() != 1 {
                let mut error = format!("label <{name}> defined multiple times at:\n");
                error.push_str(
                    &spans
                        .iter()
                        .map(|span| format!("\t{span}"))
                        .collect::<Vec<String>>()
                        .join("\n"),
                );
                errors.push(error);
            }
        }

        // Make sure each label is actually defined somewhere
        let mut pc = 0;
        for instr in items.iter() {
            let Item::Instruction(instr) = instr else {
                pc += 4;
                continue;
            };
            let label = match instr {
                Instruction::Branch { label, .. } => label,
                Instruction::BranchZero { label, .. } => label,
                Instruction::call { label } => label,
                Instruction::jal { label, .. } => label,
                Instruction::j { label } => label,
                _ => continue,
            };
            if !labels2spans.contains_key(label) {
                errors.push(format!(
                    // pad with 10 zeroes because the 0x prefix takes up 2 chars
                    "undefined label <{label}> at pc {:#010x}: {}",
                    pc, instr
                ))
            }
        }

        if !errors.is_empty() {
            return Err(anyhow!(errors.join("\n")).context("failed to parse"));
        }

        Ok(Program {
            asm: items
                .into_iter()
                .filter_map(|item| {
                    if let Item::Instruction(asm) = item {
                        Some(asm)
                    } else {
                        None
                    }
                })
                .collect(),
            labels: labels2pcs,
        })
    }

    pub fn at(&self, pc: i32) -> Option<&Instruction> {
        assert!(pc % 4 == 0, "pc was {pc}");
        self.asm.get((pc / 4) as usize)
    }

    pub fn label(&self, label: &str) -> Option<i32> {
        self.labels.get(label).map(|pc| *pc as i32)
    }
}

impl TryFrom<&str> for Program {
    type Error = anyhow::Error;

    fn try_from(s: &str) -> anyhow::Result<Program> {
        let mut lexer: Lexer = Lexer::new(s);
        Program::parse(&mut lexer)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::map;
    use indoc::indoc;

    #[test]
    fn zero_x0_alias() {
        assert_eq!("zero".parse::<Register>().unwrap(), Register::x0);
    }

    #[test]
    fn empty() {
        assert_eq!(
            Program::try_from("").unwrap(),
            Program {
                asm: vec![],
                labels: map![]
            }
        )
    }

    #[test]
    fn labels() {
        assert_eq!(
            Program::try_from(indoc! {"
                checka:
                loopa:
                checkb:
                loopb:
                li a0, 1
                li a0, 2
                after:
                
            "})
            .unwrap(),
            Program {
                asm: vec![
                    Instruction::LoadImm {
                        rd: Register::a0,
                        imm: 1,
                        op: LoadImmOp::Li
                    },
                    Instruction::LoadImm {
                        rd: Register::a0,
                        imm: 2,
                        op: LoadImmOp::Li
                    },
                ],
                labels: map![
                    "checka".to_string() => 0,
                    "loopa".to_string() => 0,
                    "checkb".to_string() => 0,
                    "loopb".to_string() => 0,
                    "after".to_string() => 8,
                ]
            }
        );
    }

    #[test]
    fn repeated_label() {
        assert!(Program::try_from(indoc! {"
                repeated:
                repeated:
                beqz zero, repeated
        "})
        .is_err());
    }

    #[test]
    fn missing_label() {
        assert!(Program::try_from(indoc! {"
            bne t1, x4, missing
        "})
        .is_err());
    }

    #[test]
    fn end_comments() {
        Program::try_from(indoc! {"
            label:
            j label
            // blah blah
        "})
        .unwrap();
        Program::try_from(indoc! {"
            label:
            j label
            # blah blah
        "})
        .unwrap();
    }

    #[test]
    fn fuzz() {
        assert!(Program::try_from(include_str!("../tests/test.s")).is_ok());
        assert!(Program::try_from(include_str!("../tests/random.s")).is_ok());
    }

    #[test]
    fn mixed() {
        assert_eq!(
            Program::try_from(indoc! {"
                addi zero, sp, 1
                addi zero, sp, 2
                label:
                beqz a0, label
            "})
            .unwrap(),
            Program {
                asm: vec![
                    Instruction::RegImm {
                        rd: Register::x0,
                        r1: Register::sp,
                        imm: 1,
                        op: RegImmOp::Addi
                    },
                    Instruction::RegImm {
                        rd: Register::x0,
                        r1: Register::sp,
                        imm: 2,
                        op: RegImmOp::Addi
                    },
                    Instruction::BranchZero {
                        r1: Register::a0,
                        label: "label".to_string(),
                        op: BranchZeroOp::Beqz
                    },
                ],
                labels: map![
                    "label".to_string() => 8,
                ]
            }
        );
    }

    #[test]
    fn instructions() {
        use BranchOp::*;
        use BranchZeroOp::*;
        use Instruction::*;
        use LoadImmOp::*;
        use LoadOp::*;
        use RegImmOp::*;
        use RegRegOp::*;
        use Register::*;
        use StoreOp::*;
        use UnaryOp::*;
        let source = indoc! {"
            lw t4, -82(s11)
            beq s7, a2, open
            jal t1, skid
            srl s9, s5, s4
            srli a7, s10, 10
            bgtz t4, tiro
            andi x0, a6, 61
            slt s4, a5, s4
            lbu s0, 0xf(s3)
            ret
            srai s0, s11, -42
            call pry
            swum:
            jalr s9, -0x18(a7)
            lhu a2, -106(t6)
            ble a7, t6, null
            bge a3, t0, pp
            meld:
            sltiu sp, s5, 0x68
            yam:
            skid:
            sltu ra, t0, s4
            and t4, a0, s11
            tors:
            pry:
            sb t6, -0x4d(a3)
            mv s0, t4
            raw:
            bltz t5, mum
            xori s3, t4, 71
            pugs:
            add tp, t5, a6
            mum:
            not t4, a4
            lh t3, -11(t4)
            jal pg
            bleu a3, s8, yam
            pp:
            sw a7, 69(a2)
            sub x0, s1, a0
            neg s1, t4
            bgeu s4, s1, pugs
            sra t2, s9, s8
            sing:
            bgtu s1, t3, lube
            addi x0, t0, 0
            slli tp, s9, 0x6
            slti a7, t4, -0x64
            hew:
            bltu t0, s7, pelt
            bgt sp, a7, keen
            sll s5, t2, a3
            xor t3, sp, x0
            corn:
            blt a6, t1, swum
            lb s10, 0x4(t5)
            sh s8, 89(s9)
            keen:
            lui s10, 64
            pg:
            null:
            jalr s10
            j corn
            bgez s1, meld
            ori s5, s1, 19
            lube:
            bne a3, s10, sing
            jr s3
            open:
            li t4, -21
            pelt:
            tiro:
            or x0, s10, s0
            bnez a3, raw
            blez s7, hew
            beqz x0, tors
        "};
        let instructions = vec![
            Load {
                rd: t4,
                offset: -82,
                r1: s11,
                op: Lw,
            },
            Branch {
                r1: s7,
                r2: a2,
                label: "open".to_string(),
                op: Beq,
            },
            jal {
                rd: t1,
                label: "skid".to_string(),
            },
            RegReg {
                rd: s9,
                r1: s5,
                r2: s4,
                op: Srl,
            },
            RegImm {
                rd: a7,
                r1: s10,
                imm: 10,
                op: Srli,
            },
            BranchZero {
                r1: t4,
                label: "tiro".to_string(),
                op: Bgtz,
            },
            RegImm {
                rd: x0,
                r1: a6,
                imm: 61,
                op: Andi,
            },
            RegReg {
                rd: s4,
                r1: a5,
                r2: s4,
                op: Slt,
            },
            Load {
                rd: s0,
                offset: 0xf,
                r1: s3,
                op: Lbu,
            },
            ret {},
            RegImm {
                rd: s0,
                r1: s11,
                imm: -42,
                op: Srai,
            },
            call {
                label: "pry".to_string(),
            },
            jalr {
                rd: s9,
                offset: -0x18,
                r1: a7,
            },
            Load {
                rd: a2,
                offset: -106,
                r1: t6,
                op: Lhu,
            },
            Branch {
                r1: a7,
                r2: t6,
                label: "null".to_string(),
                op: Ble,
            },
            Branch {
                r1: a3,
                r2: t0,
                label: "pp".to_string(),
                op: Bge,
            },
            RegImm {
                rd: sp,
                r1: s5,
                imm: 0x68,
                op: Sltiu,
            },
            RegReg {
                rd: ra,
                r1: t0,
                r2: s4,
                op: Sltu,
            },
            RegReg {
                rd: t4,
                r1: a0,
                r2: s11,
                op: And,
            },
            Store {
                r2: t6,
                offset: -0x4d,
                r1: a3,
                op: Sb,
            },
            Unary {
                rd: s0,
                r1: t4,
                op: Mv,
            },
            BranchZero {
                r1: t5,
                label: "mum".to_string(),
                op: Bltz,
            },
            RegImm {
                rd: s3,
                r1: t4,
                imm: 71,
                op: Xori,
            },
            RegReg {
                rd: tp,
                r1: t5,
                r2: a6,
                op: Add,
            },
            Unary {
                rd: t4,
                r1: a4,
                op: Not,
            },
            Load {
                rd: t3,
                offset: -11,
                r1: t4,
                op: Lh,
            },
            jal {
                rd: ra,
                label: "pg".to_string(),
            },
            Branch {
                r1: a3,
                r2: s8,
                label: "yam".to_string(),
                op: Bleu,
            },
            Store {
                r2: a7,
                offset: 69,
                r1: a2,
                op: Sw,
            },
            RegReg {
                rd: x0,
                r1: s1,
                r2: a0,
                op: Sub,
            },
            Unary {
                rd: s1,
                r1: t4,
                op: Neg,
            },
            Branch {
                r1: s4,
                r2: s1,
                label: "pugs".to_string(),
                op: Bgeu,
            },
            RegReg {
                rd: t2,
                r1: s9,
                r2: s8,
                op: Sra,
            },
            Branch {
                r1: s1,
                r2: t3,
                label: "lube".to_string(),
                op: Bgtu,
            },
            RegImm {
                rd: x0,
                r1: t0,
                imm: 0,
                op: Addi,
            },
            RegImm {
                rd: tp,
                r1: s9,
                imm: 0x6,
                op: Slli,
            },
            RegImm {
                rd: a7,
                r1: t4,
                imm: -0x64,
                op: Slti,
            },
            Branch {
                r1: t0,
                r2: s7,
                label: "pelt".to_string(),
                op: Bltu,
            },
            Branch {
                r1: sp,
                r2: a7,
                label: "keen".to_string(),
                op: Bgt,
            },
            RegReg {
                rd: s5,
                r1: t2,
                r2: a3,
                op: Sll,
            },
            RegReg {
                rd: t3,
                r1: sp,
                r2: x0,
                op: Xor,
            },
            Branch {
                r1: a6,
                r2: t1,
                label: "swum".to_string(),
                op: Blt,
            },
            Load {
                rd: s10,
                offset: 0x4,
                r1: t5,
                op: Lb,
            },
            Store {
                r2: s8,
                offset: 89,
                r1: s9,
                op: Sh,
            },
            LoadImm {
                rd: s10,
                imm: 64,
                op: Lui,
            },
            jalr {
                rd: ra,
                offset: 0,
                r1: s10,
            }, // TODO: check if the registers should be the other way
            j {
                label: "corn".to_string(),
            },
            BranchZero {
                r1: s1,
                label: "meld".to_string(),
                op: Bgez,
            },
            RegImm {
                rd: s5,
                r1: s1,
                imm: 19,
                op: Ori,
            },
            Branch {
                r1: a3,
                r2: s10,
                label: "sing".to_string(),
                op: Bne,
            },
            jr { rs: s3 },
            LoadImm {
                rd: t4,
                imm: -21,
                op: Li,
            },
            RegReg {
                rd: x0,
                r1: s10,
                r2: s0,
                op: Or,
            },
            BranchZero {
                r1: a3,
                label: "raw".to_string(),
                op: Bnez,
            },
            BranchZero {
                r1: s7,
                label: "hew".to_string(),
                op: Blez,
            },
            BranchZero {
                r1: x0,
                label: "tors".to_string(),
                op: Beqz,
            },
        ];
        assert_eq!(Program::try_from(source).unwrap().asm, instructions)
    }
}
